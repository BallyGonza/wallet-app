// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AccountEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountEventCopyWith<$Res> {
  factory $AccountEventCopyWith(
          AccountEvent value, $Res Function(AccountEvent) then) =
      _$AccountEventCopyWithImpl<$Res, AccountEvent>;
}

/// @nodoc
class _$AccountEventCopyWithImpl<$Res, $Val extends AccountEvent>
    implements $AccountEventCopyWith<$Res> {
  _$AccountEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AccountInitialEventImplCopyWith<$Res> {
  factory _$$AccountInitialEventImplCopyWith(_$AccountInitialEventImpl value,
          $Res Function(_$AccountInitialEventImpl) then) =
      __$$AccountInitialEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountInitialEventImplCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountInitialEventImpl>
    implements _$$AccountInitialEventImplCopyWith<$Res> {
  __$$AccountInitialEventImplCopyWithImpl(_$AccountInitialEventImpl _value,
      $Res Function(_$AccountInitialEventImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AccountInitialEventImpl implements AccountInitialEvent {
  const _$AccountInitialEventImpl();

  @override
  String toString() {
    return 'AccountEvent.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountInitialEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class AccountInitialEvent implements AccountEvent {
  const factory AccountInitialEvent() = _$AccountInitialEventImpl;
}

/// @nodoc
abstract class _$$AccountAddEventImplCopyWith<$Res> {
  factory _$$AccountAddEventImplCopyWith(_$AccountAddEventImpl value,
          $Res Function(_$AccountAddEventImpl) then) =
      __$$AccountAddEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AccountModel account});
}

/// @nodoc
class __$$AccountAddEventImplCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountAddEventImpl>
    implements _$$AccountAddEventImplCopyWith<$Res> {
  __$$AccountAddEventImplCopyWithImpl(
      _$AccountAddEventImpl _value, $Res Function(_$AccountAddEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
  }) {
    return _then(_$AccountAddEventImpl(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
    ));
  }
}

/// @nodoc

class _$AccountAddEventImpl implements AccountAddEvent {
  const _$AccountAddEventImpl(this.account);

  @override
  final AccountModel account;

  @override
  String toString() {
    return 'AccountEvent.add(account: $account)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountAddEventImpl &&
            (identical(other.account, account) || other.account == account));
  }

  @override
  int get hashCode => Object.hash(runtimeType, account);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountAddEventImplCopyWith<_$AccountAddEventImpl> get copyWith =>
      __$$AccountAddEventImplCopyWithImpl<_$AccountAddEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return add(account);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return add?.call(account);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(account);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }
}

abstract class AccountAddEvent implements AccountEvent {
  const factory AccountAddEvent(final AccountModel account) =
      _$AccountAddEventImpl;

  AccountModel get account;
  @JsonKey(ignore: true)
  _$$AccountAddEventImplCopyWith<_$AccountAddEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountRemoveEventImplCopyWith<$Res> {
  factory _$$AccountRemoveEventImplCopyWith(_$AccountRemoveEventImpl value,
          $Res Function(_$AccountRemoveEventImpl) then) =
      __$$AccountRemoveEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AccountModel account});
}

/// @nodoc
class __$$AccountRemoveEventImplCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountRemoveEventImpl>
    implements _$$AccountRemoveEventImplCopyWith<$Res> {
  __$$AccountRemoveEventImplCopyWithImpl(_$AccountRemoveEventImpl _value,
      $Res Function(_$AccountRemoveEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
  }) {
    return _then(_$AccountRemoveEventImpl(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
    ));
  }
}

/// @nodoc

class _$AccountRemoveEventImpl implements AccountRemoveEvent {
  const _$AccountRemoveEventImpl(this.account);

  @override
  final AccountModel account;

  @override
  String toString() {
    return 'AccountEvent.remove(account: $account)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountRemoveEventImpl &&
            (identical(other.account, account) || other.account == account));
  }

  @override
  int get hashCode => Object.hash(runtimeType, account);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountRemoveEventImplCopyWith<_$AccountRemoveEventImpl> get copyWith =>
      __$$AccountRemoveEventImplCopyWithImpl<_$AccountRemoveEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return remove(account);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return remove?.call(account);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(account);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return remove(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return remove?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(this);
    }
    return orElse();
  }
}

abstract class AccountRemoveEvent implements AccountEvent {
  const factory AccountRemoveEvent(final AccountModel account) =
      _$AccountRemoveEventImpl;

  AccountModel get account;
  @JsonKey(ignore: true)
  _$$AccountRemoveEventImplCopyWith<_$AccountRemoveEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountAddTransactionEventImplCopyWith<$Res> {
  factory _$$AccountAddTransactionEventImplCopyWith(
          _$AccountAddTransactionEventImpl value,
          $Res Function(_$AccountAddTransactionEventImpl) then) =
      __$$AccountAddTransactionEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AccountModel account, TransactionModel transaction});
}

/// @nodoc
class __$$AccountAddTransactionEventImplCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountAddTransactionEventImpl>
    implements _$$AccountAddTransactionEventImplCopyWith<$Res> {
  __$$AccountAddTransactionEventImplCopyWithImpl(
      _$AccountAddTransactionEventImpl _value,
      $Res Function(_$AccountAddTransactionEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
    Object? transaction = null,
  }) {
    return _then(_$AccountAddTransactionEventImpl(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
      null == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as TransactionModel,
    ));
  }
}

/// @nodoc

class _$AccountAddTransactionEventImpl implements AccountAddTransactionEvent {
  const _$AccountAddTransactionEventImpl(this.account, this.transaction);

  @override
  final AccountModel account;
  @override
  final TransactionModel transaction;

  @override
  String toString() {
    return 'AccountEvent.addTransaction(account: $account, transaction: $transaction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountAddTransactionEventImpl &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hash(runtimeType, account, transaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountAddTransactionEventImplCopyWith<_$AccountAddTransactionEventImpl>
      get copyWith => __$$AccountAddTransactionEventImplCopyWithImpl<
          _$AccountAddTransactionEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return addTransaction(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return addTransaction?.call(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (addTransaction != null) {
      return addTransaction(account, transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return addTransaction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return addTransaction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (addTransaction != null) {
      return addTransaction(this);
    }
    return orElse();
  }
}

abstract class AccountAddTransactionEvent implements AccountEvent {
  const factory AccountAddTransactionEvent(
          final AccountModel account, final TransactionModel transaction) =
      _$AccountAddTransactionEventImpl;

  AccountModel get account;
  TransactionModel get transaction;
  @JsonKey(ignore: true)
  _$$AccountAddTransactionEventImplCopyWith<_$AccountAddTransactionEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountUpdateTransactionEventImplCopyWith<$Res> {
  factory _$$AccountUpdateTransactionEventImplCopyWith(
          _$AccountUpdateTransactionEventImpl value,
          $Res Function(_$AccountUpdateTransactionEventImpl) then) =
      __$$AccountUpdateTransactionEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {AccountModel account,
      AccountModel? newAccount,
      TransactionModel transaction});
}

/// @nodoc
class __$$AccountUpdateTransactionEventImplCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res,
        _$AccountUpdateTransactionEventImpl>
    implements _$$AccountUpdateTransactionEventImplCopyWith<$Res> {
  __$$AccountUpdateTransactionEventImplCopyWithImpl(
      _$AccountUpdateTransactionEventImpl _value,
      $Res Function(_$AccountUpdateTransactionEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
    Object? newAccount = freezed,
    Object? transaction = null,
  }) {
    return _then(_$AccountUpdateTransactionEventImpl(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
      freezed == newAccount
          ? _value.newAccount
          : newAccount // ignore: cast_nullable_to_non_nullable
              as AccountModel?,
      null == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as TransactionModel,
    ));
  }
}

/// @nodoc

class _$AccountUpdateTransactionEventImpl
    implements AccountUpdateTransactionEvent {
  const _$AccountUpdateTransactionEventImpl(
      this.account, this.newAccount, this.transaction);

  @override
  final AccountModel account;
  @override
  final AccountModel? newAccount;
  @override
  final TransactionModel transaction;

  @override
  String toString() {
    return 'AccountEvent.updateTransaction(account: $account, newAccount: $newAccount, transaction: $transaction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountUpdateTransactionEventImpl &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.newAccount, newAccount) ||
                other.newAccount == newAccount) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, account, newAccount, transaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountUpdateTransactionEventImplCopyWith<
          _$AccountUpdateTransactionEventImpl>
      get copyWith => __$$AccountUpdateTransactionEventImplCopyWithImpl<
          _$AccountUpdateTransactionEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return updateTransaction(account, newAccount, transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return updateTransaction?.call(account, newAccount, transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (updateTransaction != null) {
      return updateTransaction(account, newAccount, transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return updateTransaction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return updateTransaction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (updateTransaction != null) {
      return updateTransaction(this);
    }
    return orElse();
  }
}

abstract class AccountUpdateTransactionEvent implements AccountEvent {
  const factory AccountUpdateTransactionEvent(
      final AccountModel account,
      final AccountModel? newAccount,
      final TransactionModel transaction) = _$AccountUpdateTransactionEventImpl;

  AccountModel get account;
  AccountModel? get newAccount;
  TransactionModel get transaction;
  @JsonKey(ignore: true)
  _$$AccountUpdateTransactionEventImplCopyWith<
          _$AccountUpdateTransactionEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountRemoveTransactionEventImplCopyWith<$Res> {
  factory _$$AccountRemoveTransactionEventImplCopyWith(
          _$AccountRemoveTransactionEventImpl value,
          $Res Function(_$AccountRemoveTransactionEventImpl) then) =
      __$$AccountRemoveTransactionEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AccountModel account, TransactionModel transaction});
}

/// @nodoc
class __$$AccountRemoveTransactionEventImplCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res,
        _$AccountRemoveTransactionEventImpl>
    implements _$$AccountRemoveTransactionEventImplCopyWith<$Res> {
  __$$AccountRemoveTransactionEventImplCopyWithImpl(
      _$AccountRemoveTransactionEventImpl _value,
      $Res Function(_$AccountRemoveTransactionEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
    Object? transaction = null,
  }) {
    return _then(_$AccountRemoveTransactionEventImpl(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
      null == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as TransactionModel,
    ));
  }
}

/// @nodoc

class _$AccountRemoveTransactionEventImpl
    implements AccountRemoveTransactionEvent {
  const _$AccountRemoveTransactionEventImpl(this.account, this.transaction);

  @override
  final AccountModel account;
  @override
  final TransactionModel transaction;

  @override
  String toString() {
    return 'AccountEvent.removeTransaction(account: $account, transaction: $transaction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountRemoveTransactionEventImpl &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hash(runtimeType, account, transaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountRemoveTransactionEventImplCopyWith<
          _$AccountRemoveTransactionEventImpl>
      get copyWith => __$$AccountRemoveTransactionEventImplCopyWithImpl<
          _$AccountRemoveTransactionEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return removeTransaction(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return removeTransaction?.call(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, AccountModel? newAccount,
            TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (removeTransaction != null) {
      return removeTransaction(account, transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return removeTransaction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return removeTransaction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (removeTransaction != null) {
      return removeTransaction(this);
    }
    return orElse();
  }
}

abstract class AccountRemoveTransactionEvent implements AccountEvent {
  const factory AccountRemoveTransactionEvent(
          final AccountModel account, final TransactionModel transaction) =
      _$AccountRemoveTransactionEventImpl;

  AccountModel get account;
  TransactionModel get transaction;
  @JsonKey(ignore: true)
  _$$AccountRemoveTransactionEventImplCopyWith<
          _$AccountRemoveTransactionEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}
