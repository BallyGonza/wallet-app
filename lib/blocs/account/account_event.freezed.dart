// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AccountEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountEventCopyWith<$Res> {
  factory $AccountEventCopyWith(
          AccountEvent value, $Res Function(AccountEvent) then) =
      _$AccountEventCopyWithImpl<$Res, AccountEvent>;
}

/// @nodoc
class _$AccountEventCopyWithImpl<$Res, $Val extends AccountEvent>
    implements $AccountEventCopyWith<$Res> {
  _$AccountEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AccountInitialEventCopyWith<$Res> {
  factory _$$AccountInitialEventCopyWith(_$AccountInitialEvent value,
          $Res Function(_$AccountInitialEvent) then) =
      __$$AccountInitialEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AccountInitialEventCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountInitialEvent>
    implements _$$AccountInitialEventCopyWith<$Res> {
  __$$AccountInitialEventCopyWithImpl(
      _$AccountInitialEvent _value, $Res Function(_$AccountInitialEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AccountInitialEvent implements AccountInitialEvent {
  const _$AccountInitialEvent();

  @override
  String toString() {
    return 'AccountEvent.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AccountInitialEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class AccountInitialEvent implements AccountEvent {
  const factory AccountInitialEvent() = _$AccountInitialEvent;
}

/// @nodoc
abstract class _$$AccountAddEventCopyWith<$Res> {
  factory _$$AccountAddEventCopyWith(
          _$AccountAddEvent value, $Res Function(_$AccountAddEvent) then) =
      __$$AccountAddEventCopyWithImpl<$Res>;
  @useResult
  $Res call({AccountModel account});
}

/// @nodoc
class __$$AccountAddEventCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountAddEvent>
    implements _$$AccountAddEventCopyWith<$Res> {
  __$$AccountAddEventCopyWithImpl(
      _$AccountAddEvent _value, $Res Function(_$AccountAddEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
  }) {
    return _then(_$AccountAddEvent(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
    ));
  }
}

/// @nodoc

class _$AccountAddEvent implements AccountAddEvent {
  const _$AccountAddEvent(this.account);

  @override
  final AccountModel account;

  @override
  String toString() {
    return 'AccountEvent.add(account: $account)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountAddEvent &&
            (identical(other.account, account) || other.account == account));
  }

  @override
  int get hashCode => Object.hash(runtimeType, account);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountAddEventCopyWith<_$AccountAddEvent> get copyWith =>
      __$$AccountAddEventCopyWithImpl<_$AccountAddEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return add(account);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return add?.call(account);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(account);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }
}

abstract class AccountAddEvent implements AccountEvent {
  const factory AccountAddEvent(final AccountModel account) = _$AccountAddEvent;

  AccountModel get account;
  @JsonKey(ignore: true)
  _$$AccountAddEventCopyWith<_$AccountAddEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountRemoveEventCopyWith<$Res> {
  factory _$$AccountRemoveEventCopyWith(_$AccountRemoveEvent value,
          $Res Function(_$AccountRemoveEvent) then) =
      __$$AccountRemoveEventCopyWithImpl<$Res>;
  @useResult
  $Res call({AccountModel account});
}

/// @nodoc
class __$$AccountRemoveEventCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountRemoveEvent>
    implements _$$AccountRemoveEventCopyWith<$Res> {
  __$$AccountRemoveEventCopyWithImpl(
      _$AccountRemoveEvent _value, $Res Function(_$AccountRemoveEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
  }) {
    return _then(_$AccountRemoveEvent(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
    ));
  }
}

/// @nodoc

class _$AccountRemoveEvent implements AccountRemoveEvent {
  const _$AccountRemoveEvent(this.account);

  @override
  final AccountModel account;

  @override
  String toString() {
    return 'AccountEvent.remove(account: $account)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountRemoveEvent &&
            (identical(other.account, account) || other.account == account));
  }

  @override
  int get hashCode => Object.hash(runtimeType, account);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountRemoveEventCopyWith<_$AccountRemoveEvent> get copyWith =>
      __$$AccountRemoveEventCopyWithImpl<_$AccountRemoveEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return remove(account);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return remove?.call(account);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(account);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return remove(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return remove?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (remove != null) {
      return remove(this);
    }
    return orElse();
  }
}

abstract class AccountRemoveEvent implements AccountEvent {
  const factory AccountRemoveEvent(final AccountModel account) =
      _$AccountRemoveEvent;

  AccountModel get account;
  @JsonKey(ignore: true)
  _$$AccountRemoveEventCopyWith<_$AccountRemoveEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountAddTransactionEventCopyWith<$Res> {
  factory _$$AccountAddTransactionEventCopyWith(
          _$AccountAddTransactionEvent value,
          $Res Function(_$AccountAddTransactionEvent) then) =
      __$$AccountAddTransactionEventCopyWithImpl<$Res>;
  @useResult
  $Res call({AccountModel account, TransactionModel transaction});
}

/// @nodoc
class __$$AccountAddTransactionEventCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountAddTransactionEvent>
    implements _$$AccountAddTransactionEventCopyWith<$Res> {
  __$$AccountAddTransactionEventCopyWithImpl(
      _$AccountAddTransactionEvent _value,
      $Res Function(_$AccountAddTransactionEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
    Object? transaction = null,
  }) {
    return _then(_$AccountAddTransactionEvent(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
      null == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as TransactionModel,
    ));
  }
}

/// @nodoc

class _$AccountAddTransactionEvent implements AccountAddTransactionEvent {
  const _$AccountAddTransactionEvent(this.account, this.transaction);

  @override
  final AccountModel account;
  @override
  final TransactionModel transaction;

  @override
  String toString() {
    return 'AccountEvent.addTransaction(account: $account, transaction: $transaction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountAddTransactionEvent &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hash(runtimeType, account, transaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountAddTransactionEventCopyWith<_$AccountAddTransactionEvent>
      get copyWith => __$$AccountAddTransactionEventCopyWithImpl<
          _$AccountAddTransactionEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return addTransaction(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return addTransaction?.call(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (addTransaction != null) {
      return addTransaction(account, transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return addTransaction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return addTransaction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (addTransaction != null) {
      return addTransaction(this);
    }
    return orElse();
  }
}

abstract class AccountAddTransactionEvent implements AccountEvent {
  const factory AccountAddTransactionEvent(
          final AccountModel account, final TransactionModel transaction) =
      _$AccountAddTransactionEvent;

  AccountModel get account;
  TransactionModel get transaction;
  @JsonKey(ignore: true)
  _$$AccountAddTransactionEventCopyWith<_$AccountAddTransactionEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountUpdateTransactionEventCopyWith<$Res> {
  factory _$$AccountUpdateTransactionEventCopyWith(
          _$AccountUpdateTransactionEvent value,
          $Res Function(_$AccountUpdateTransactionEvent) then) =
      __$$AccountUpdateTransactionEventCopyWithImpl<$Res>;
  @useResult
  $Res call({AccountModel account, TransactionModel transaction});
}

/// @nodoc
class __$$AccountUpdateTransactionEventCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountUpdateTransactionEvent>
    implements _$$AccountUpdateTransactionEventCopyWith<$Res> {
  __$$AccountUpdateTransactionEventCopyWithImpl(
      _$AccountUpdateTransactionEvent _value,
      $Res Function(_$AccountUpdateTransactionEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
    Object? transaction = null,
  }) {
    return _then(_$AccountUpdateTransactionEvent(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
      null == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as TransactionModel,
    ));
  }
}

/// @nodoc

class _$AccountUpdateTransactionEvent implements AccountUpdateTransactionEvent {
  const _$AccountUpdateTransactionEvent(this.account, this.transaction);

  @override
  final AccountModel account;
  @override
  final TransactionModel transaction;

  @override
  String toString() {
    return 'AccountEvent.updateTransaction(account: $account, transaction: $transaction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountUpdateTransactionEvent &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hash(runtimeType, account, transaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountUpdateTransactionEventCopyWith<_$AccountUpdateTransactionEvent>
      get copyWith => __$$AccountUpdateTransactionEventCopyWithImpl<
          _$AccountUpdateTransactionEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return updateTransaction(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return updateTransaction?.call(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (updateTransaction != null) {
      return updateTransaction(account, transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return updateTransaction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return updateTransaction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (updateTransaction != null) {
      return updateTransaction(this);
    }
    return orElse();
  }
}

abstract class AccountUpdateTransactionEvent implements AccountEvent {
  const factory AccountUpdateTransactionEvent(
          final AccountModel account, final TransactionModel transaction) =
      _$AccountUpdateTransactionEvent;

  AccountModel get account;
  TransactionModel get transaction;
  @JsonKey(ignore: true)
  _$$AccountUpdateTransactionEventCopyWith<_$AccountUpdateTransactionEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AccountRemoveTransactionEventCopyWith<$Res> {
  factory _$$AccountRemoveTransactionEventCopyWith(
          _$AccountRemoveTransactionEvent value,
          $Res Function(_$AccountRemoveTransactionEvent) then) =
      __$$AccountRemoveTransactionEventCopyWithImpl<$Res>;
  @useResult
  $Res call({AccountModel account, TransactionModel transaction});
}

/// @nodoc
class __$$AccountRemoveTransactionEventCopyWithImpl<$Res>
    extends _$AccountEventCopyWithImpl<$Res, _$AccountRemoveTransactionEvent>
    implements _$$AccountRemoveTransactionEventCopyWith<$Res> {
  __$$AccountRemoveTransactionEventCopyWithImpl(
      _$AccountRemoveTransactionEvent _value,
      $Res Function(_$AccountRemoveTransactionEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? account = null,
    Object? transaction = null,
  }) {
    return _then(_$AccountRemoveTransactionEvent(
      null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as AccountModel,
      null == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as TransactionModel,
    ));
  }
}

/// @nodoc

class _$AccountRemoveTransactionEvent implements AccountRemoveTransactionEvent {
  const _$AccountRemoveTransactionEvent(this.account, this.transaction);

  @override
  final AccountModel account;
  @override
  final TransactionModel transaction;

  @override
  String toString() {
    return 'AccountEvent.removeTransaction(account: $account, transaction: $transaction)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountRemoveTransactionEvent &&
            (identical(other.account, account) || other.account == account) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hash(runtimeType, account, transaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountRemoveTransactionEventCopyWith<_$AccountRemoveTransactionEvent>
      get copyWith => __$$AccountRemoveTransactionEventCopyWithImpl<
          _$AccountRemoveTransactionEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(AccountModel account) add,
    required TResult Function(AccountModel account) remove,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        addTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        updateTransaction,
    required TResult Function(
            AccountModel account, TransactionModel transaction)
        removeTransaction,
  }) {
    return removeTransaction(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(AccountModel account)? add,
    TResult? Function(AccountModel account)? remove,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult? Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
  }) {
    return removeTransaction?.call(account, transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(AccountModel account)? add,
    TResult Function(AccountModel account)? remove,
    TResult Function(AccountModel account, TransactionModel transaction)?
        addTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        updateTransaction,
    TResult Function(AccountModel account, TransactionModel transaction)?
        removeTransaction,
    required TResult orElse(),
  }) {
    if (removeTransaction != null) {
      return removeTransaction(account, transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AccountInitialEvent value) init,
    required TResult Function(AccountAddEvent value) add,
    required TResult Function(AccountRemoveEvent value) remove,
    required TResult Function(AccountAddTransactionEvent value) addTransaction,
    required TResult Function(AccountUpdateTransactionEvent value)
        updateTransaction,
    required TResult Function(AccountRemoveTransactionEvent value)
        removeTransaction,
  }) {
    return removeTransaction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AccountInitialEvent value)? init,
    TResult? Function(AccountAddEvent value)? add,
    TResult? Function(AccountRemoveEvent value)? remove,
    TResult? Function(AccountAddTransactionEvent value)? addTransaction,
    TResult? Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult? Function(AccountRemoveTransactionEvent value)? removeTransaction,
  }) {
    return removeTransaction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AccountInitialEvent value)? init,
    TResult Function(AccountAddEvent value)? add,
    TResult Function(AccountRemoveEvent value)? remove,
    TResult Function(AccountAddTransactionEvent value)? addTransaction,
    TResult Function(AccountUpdateTransactionEvent value)? updateTransaction,
    TResult Function(AccountRemoveTransactionEvent value)? removeTransaction,
    required TResult orElse(),
  }) {
    if (removeTransaction != null) {
      return removeTransaction(this);
    }
    return orElse();
  }
}

abstract class AccountRemoveTransactionEvent implements AccountEvent {
  const factory AccountRemoveTransactionEvent(
          final AccountModel account, final TransactionModel transaction) =
      _$AccountRemoveTransactionEvent;

  AccountModel get account;
  TransactionModel get transaction;
  @JsonKey(ignore: true)
  _$$AccountRemoveTransactionEventCopyWith<_$AccountRemoveTransactionEvent>
      get copyWith => throw _privateConstructorUsedError;
}
